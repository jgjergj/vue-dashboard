/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.12.1.0 (NJsonSchema v10.4.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AccountsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<AccountVM[]> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<AccountVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountVM[]>(<any>null);
    }

    create(command: CreateAccountCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateAccountCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Accounts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<AccountVM> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AccountVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class ArbitrageBetsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<ArbitrageBetVM[]> {
        let url_ = this.baseUrl + "/api/ArbitrageBets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ArbitrageBetVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArbitrageBetVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageBetVM[]>(<any>null);
    }

    create(command: CreateArbitrageBetCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/ArbitrageBets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateArbitrageBetCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/ArbitrageBets?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<ArbitrageBetVM> {
        let url_ = this.baseUrl + "/api/ArbitrageBets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ArbitrageBetVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArbitrageBetVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageBetVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/ArbitrageBets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    updateStatus(id: number | undefined, command: UpdateArbitrageBetStatusCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/ArbitrageBets/UpdateStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class ArbitrageMatchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<ArbitrageMatchVM[]> {
        let url_ = this.baseUrl + "/api/ArbitrageMatches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ArbitrageMatchVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArbitrageMatchVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageMatchVM[]>(<any>null);
    }

    create(command: CreateArbitrageMatchCommand): Promise<string> {
        let url_ = this.baseUrl + "/api/ArbitrageMatches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    update(id: string | undefined, command: UpdateArbitrageMatchCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/ArbitrageMatches?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: string): Promise<ArbitrageMatchVM> {
        let url_ = this.baseUrl + "/api/ArbitrageMatches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ArbitrageMatchVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArbitrageMatchVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageMatchVM>(<any>null);
    }

    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/ArbitrageMatches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class ClientsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<ClientVM[]> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ClientVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientVM[]>(<any>null);
    }

    create(command: CreateClientCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateClientCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Clients?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<ClientVM> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ClientVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    getClientsWithNoOperator(): Promise<ClientVM[]> {
        let url_ = this.baseUrl + "/api/Clients/Unassigned";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClientsWithNoOperator(_response);
        });
    }

    protected processGetClientsWithNoOperator(response: Response): Promise<ClientVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientVM[]>(<any>null);
    }
}

export class CompaniesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<CompanyVM[]> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CompanyVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyVM[]>(<any>null);
    }

    create(command: CreateCompanyCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateCompanyCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Companies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<CompanyVM> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CompanyVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class CurrenciesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<CurrencyVM[]> {
        let url_ = this.baseUrl + "/api/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CurrencyVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrencyVM[]>(<any>null);
    }

    create(command: CreateCurrencyCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateCurrencyCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Currencies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<CurrencyVM> {
        let url_ = this.baseUrl + "/api/Currencies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CurrencyVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrencyVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Currencies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class DepartmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<DepartmentVM[]> {
        let url_ = this.baseUrl + "/api/Departments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<DepartmentVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentVM[]>(<any>null);
    }

    create(command: CreateDepartmentCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Departments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateDepartmentCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Departments?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<DepartmentVM> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DepartmentVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class LeaguesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<LeagueVM[]> {
        let url_ = this.baseUrl + "/api/Leagues";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<LeagueVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LeagueVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeagueVM[]>(<any>null);
    }

    create(command: CreateLeagueCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Leagues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateLeagueCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Leagues?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<LeagueVM> {
        let url_ = this.baseUrl + "/api/Leagues/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LeagueVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeagueVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeagueVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Leagues/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class OperatorsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<OperatorVM[]> {
        let url_ = this.baseUrl + "/api/Operators";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<OperatorVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperatorVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperatorVM[]>(<any>null);
    }

    create(command: CreateOperatorCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Operators";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateOperatorCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Operators?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<OperatorVM> {
        let url_ = this.baseUrl + "/api/Operators/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OperatorVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperatorVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperatorVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Operators/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    getOperatorsWithNoDepartment(): Promise<OperatorVM[]> {
        let url_ = this.baseUrl + "/api/Operators/Unassigned";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOperatorsWithNoDepartment(_response);
        });
    }

    protected processGetOperatorsWithNoDepartment(response: Response): Promise<OperatorVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperatorVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperatorVM[]>(<any>null);
    }
}

export class PaymentAccountsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<PaymentAccountVM[]> {
        let url_ = this.baseUrl + "/api/PaymentAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PaymentAccountVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentAccountVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentAccountVM[]>(<any>null);
    }

    create(command: CreatePaymentAccountCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/PaymentAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdatePaymentAccountCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/PaymentAccounts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<PaymentAccountVM> {
        let url_ = this.baseUrl + "/api/PaymentAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PaymentAccountVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentAccountVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/PaymentAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class SportsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<SportVM[]> {
        let url_ = this.baseUrl + "/api/Sports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<SportVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SportVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SportVM[]>(<any>null);
    }

    create(command: CreateSportCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Sports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateSportCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Sports?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<SportVM> {
        let url_ = this.baseUrl + "/api/Sports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SportVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SportVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SportVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Sports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class StatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<StateVM[]> {
        let url_ = this.baseUrl + "/api/States";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<StateVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StateVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateVM[]>(<any>null);
    }

    create(command: CreateStateCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/States";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateStateCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/States?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<StateVM> {
        let url_ = this.baseUrl + "/api/States/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<StateVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StateVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/States/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class StatusesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<StatusVM[]> {
        let url_ = this.baseUrl + "/api/Statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<StatusVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusVM[]>(<any>null);
    }

    create(command: CreateStatusCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateStatusCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Statuses?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<StatusVM> {
        let url_ = this.baseUrl + "/api/Statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<StatusVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class TeamsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<TeamVM[]> {
        let url_ = this.baseUrl + "/api/Teams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<TeamVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeamVM[]>(<any>null);
    }

    create(command: CreateTeamCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Teams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateTeamCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Teams?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<TeamVM> {
        let url_ = this.baseUrl + "/api/Teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TeamVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeamVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Teams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class TypesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<TypeVM[]> {
        let url_ = this.baseUrl + "/api/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<TypeVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TypeVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TypeVM[]>(<any>null);
    }

    create(command: CreateTypeCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number | undefined, command: UpdateTypeCommand): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Types?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }

    get(id: number): Promise<TypeVM> {
        let url_ = this.baseUrl + "/api/Types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TypeVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TypeVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TypeVM>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/Types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export class AccountVM implements IAccountVM {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    company?: CompanyVM | undefined;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currency?: CurrencyVM | undefined;
    openingDate?: Date;
    loginLink?: string | undefined;
    status?: StatusVM | undefined;
    type?: TypeVM | undefined;
    state?: StateVM | undefined;
    operator?: OperatorVM | undefined;
    paymentAccount?: PaymentAccountVM | undefined;

    constructor(data?: IAccountVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.company = _data["company"] ? CompanyVM.fromJS(_data["company"]) : <any>undefined;
            this.balance = _data["balance"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.currency = _data["currency"] ? CurrencyVM.fromJS(_data["currency"]) : <any>undefined;
            this.openingDate = _data["openingDate"] ? new Date(_data["openingDate"].toString()) : <any>undefined;
            this.loginLink = _data["loginLink"];
            this.status = _data["status"] ? StatusVM.fromJS(_data["status"]) : <any>undefined;
            this.type = _data["type"] ? TypeVM.fromJS(_data["type"]) : <any>undefined;
            this.state = _data["state"] ? StateVM.fromJS(_data["state"]) : <any>undefined;
            this.operator = _data["operator"] ? OperatorVM.fromJS(_data["operator"]) : <any>undefined;
            this.paymentAccount = _data["paymentAccount"] ? PaymentAccountVM.fromJS(_data["paymentAccount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountVM {
        data = typeof data === 'object' ? data : {};
        let result = new AccountVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["openingDate"] = this.openingDate ? this.openingDate.toISOString() : <any>undefined;
        data["loginLink"] = this.loginLink;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["operator"] = this.operator ? this.operator.toJSON() : <any>undefined;
        data["paymentAccount"] = this.paymentAccount ? this.paymentAccount.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAccountVM {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    company?: CompanyVM | undefined;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currency?: CurrencyVM | undefined;
    openingDate?: Date;
    loginLink?: string | undefined;
    status?: StatusVM | undefined;
    type?: TypeVM | undefined;
    state?: StateVM | undefined;
    operator?: OperatorVM | undefined;
    paymentAccount?: PaymentAccountVM | undefined;
}

export class CompanyVM implements ICompanyVM {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    type?: TypeVM | undefined;

    constructor(data?: ICompanyVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.loginLink = _data["loginLink"];
            this.type = _data["type"] ? TypeVM.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyVM {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["loginLink"] = this.loginLink;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyVM {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    type?: TypeVM | undefined;
}

export class TypeVM implements ITypeVM {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: ITypeVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): TypeVM {
        data = typeof data === 'object' ? data : {};
        let result = new TypeVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface ITypeVM {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;
}

export class CurrencyVM implements ICurrencyVM {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICurrencyVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CurrencyVM {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICurrencyVM {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class StatusVM implements IStatusVM {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: IStatusVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): StatusVM {
        data = typeof data === 'object' ? data : {};
        let result = new StatusVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface IStatusVM {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;
}

export class StateVM implements IStateVM {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IStateVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): StateVM {
        data = typeof data === 'object' ? data : {};
        let result = new StateVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface IStateVM {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class OperatorVM implements IOperatorVM {
    id?: number;
    name?: string | undefined;
    balance?: number;
    department?: DepartmentVM | undefined;

    constructor(data?: IOperatorVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.department = _data["department"] ? DepartmentVM.fromJS(_data["department"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OperatorVM {
        data = typeof data === 'object' ? data : {};
        let result = new OperatorVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOperatorVM {
    id?: number;
    name?: string | undefined;
    balance?: number;
    department?: DepartmentVM | undefined;
}

export class DepartmentVM implements IDepartmentVM {
    id?: number;
    name?: string | undefined;
    balance?: number;

    constructor(data?: IDepartmentVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): DepartmentVM {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IDepartmentVM {
    id?: number;
    name?: string | undefined;
    balance?: number;
}

export class PaymentAccountVM implements IPaymentAccountVM {
    id?: number;
    sport?: SportVM | undefined;
    company?: CompanyVM | undefined;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    state?: StateVM | undefined;
    status?: StatusVM | undefined;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;

    constructor(data?: IPaymentAccountVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sport = _data["sport"] ? SportVM.fromJS(_data["sport"]) : <any>undefined;
            this.company = _data["company"] ? CompanyVM.fromJS(_data["company"]) : <any>undefined;
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.state = _data["state"] ? StateVM.fromJS(_data["state"]) : <any>undefined;
            this.status = _data["status"] ? StatusVM.fromJS(_data["status"]) : <any>undefined;
            this.balance = _data["balance"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.documentExpiry = _data["documentExpiry"] ? new Date(_data["documentExpiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentAccountVM {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAccountVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sport"] = this.sport ? this.sport.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["documentExpiry"] = this.documentExpiry ? this.documentExpiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPaymentAccountVM {
    id?: number;
    sport?: SportVM | undefined;
    company?: CompanyVM | undefined;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    state?: StateVM | undefined;
    status?: StatusVM | undefined;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;
}

export class SportVM implements ISportVM {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ISportVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SportVM {
        data = typeof data === 'object' ? data : {};
        let result = new SportVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISportVM {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateAccountCommand implements ICreateAccountCommand {
    name?: string | undefined;
    surname?: string | undefined;
    companyId?: number;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currencyId?: number;
    openingDate?: Date;
    loginLink?: string | undefined;
    statusId?: number;
    typeId?: number;
    stateId?: number;
    operatorId?: number;
    paymentAccountId?: number;

    constructor(data?: ICreateAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.companyId = _data["companyId"];
            this.balance = _data["balance"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.currencyId = _data["currencyId"];
            this.openingDate = _data["openingDate"] ? new Date(_data["openingDate"].toString()) : <any>undefined;
            this.loginLink = _data["loginLink"];
            this.statusId = _data["statusId"];
            this.typeId = _data["typeId"];
            this.stateId = _data["stateId"];
            this.operatorId = _data["operatorId"];
            this.paymentAccountId = _data["paymentAccountId"];
        }
    }

    static fromJS(data: any): CreateAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["companyId"] = this.companyId;
        data["balance"] = this.balance;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["currencyId"] = this.currencyId;
        data["openingDate"] = this.openingDate ? this.openingDate.toISOString() : <any>undefined;
        data["loginLink"] = this.loginLink;
        data["statusId"] = this.statusId;
        data["typeId"] = this.typeId;
        data["stateId"] = this.stateId;
        data["operatorId"] = this.operatorId;
        data["paymentAccountId"] = this.paymentAccountId;
        return data; 
    }
}

export interface ICreateAccountCommand {
    name?: string | undefined;
    surname?: string | undefined;
    companyId?: number;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currencyId?: number;
    openingDate?: Date;
    loginLink?: string | undefined;
    statusId?: number;
    typeId?: number;
    stateId?: number;
    operatorId?: number;
    paymentAccountId?: number;
}

/** Represents a void type, since Void is not a valid return type in C#. */
export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface IUnit {
}

export class UpdateAccountCommand implements IUpdateAccountCommand {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    companyId?: number;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currencyId?: number;
    openingDate?: Date;
    loginLink?: string | undefined;
    statusId?: number;
    typeId?: number;
    stateId?: number;
    operatorId?: number;
    paymentAccountId?: number;

    constructor(data?: IUpdateAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.companyId = _data["companyId"];
            this.balance = _data["balance"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.currencyId = _data["currencyId"];
            this.openingDate = _data["openingDate"] ? new Date(_data["openingDate"].toString()) : <any>undefined;
            this.loginLink = _data["loginLink"];
            this.statusId = _data["statusId"];
            this.typeId = _data["typeId"];
            this.stateId = _data["stateId"];
            this.operatorId = _data["operatorId"];
            this.paymentAccountId = _data["paymentAccountId"];
        }
    }

    static fromJS(data: any): UpdateAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["companyId"] = this.companyId;
        data["balance"] = this.balance;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["currencyId"] = this.currencyId;
        data["openingDate"] = this.openingDate ? this.openingDate.toISOString() : <any>undefined;
        data["loginLink"] = this.loginLink;
        data["statusId"] = this.statusId;
        data["typeId"] = this.typeId;
        data["stateId"] = this.stateId;
        data["operatorId"] = this.operatorId;
        data["paymentAccountId"] = this.paymentAccountId;
        return data; 
    }
}

export interface IUpdateAccountCommand {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    companyId?: number;
    balance?: number;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    birthday?: Date;
    address?: string | undefined;
    phone?: string | undefined;
    currencyId?: number;
    openingDate?: Date;
    loginLink?: string | undefined;
    statusId?: number;
    typeId?: number;
    stateId?: number;
    operatorId?: number;
    paymentAccountId?: number;
}

export class ArbitrageBetVM implements IArbitrageBetVM {
    id?: number;
    arbitrageMatch?: ArbitrageMatchVM | undefined;
    company?: CompanyVM | undefined;
    account?: AccountVM | undefined;
    line?: string | undefined;
    status?: StatusVM | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    type?: TypeVM | undefined;

    constructor(data?: IArbitrageBetVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.arbitrageMatch = _data["arbitrageMatch"] ? ArbitrageMatchVM.fromJS(_data["arbitrageMatch"]) : <any>undefined;
            this.company = _data["company"] ? CompanyVM.fromJS(_data["company"]) : <any>undefined;
            this.account = _data["account"] ? AccountVM.fromJS(_data["account"]) : <any>undefined;
            this.line = _data["line"];
            this.status = _data["status"] ? StatusVM.fromJS(_data["status"]) : <any>undefined;
            this.stake = _data["stake"];
            this.odd = _data["odd"];
            this.return = _data["return"];
            this.profit = _data["profit"];
            this.profitARB = _data["profitARB"];
            this.type = _data["type"] ? TypeVM.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ArbitrageBetVM {
        data = typeof data === 'object' ? data : {};
        let result = new ArbitrageBetVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["arbitrageMatch"] = this.arbitrageMatch ? this.arbitrageMatch.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["line"] = this.line;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["stake"] = this.stake;
        data["odd"] = this.odd;
        data["return"] = this.return;
        data["profit"] = this.profit;
        data["profitARB"] = this.profitARB;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IArbitrageBetVM {
    id?: number;
    arbitrageMatch?: ArbitrageMatchVM | undefined;
    company?: CompanyVM | undefined;
    account?: AccountVM | undefined;
    line?: string | undefined;
    status?: StatusVM | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    type?: TypeVM | undefined;
}

export class ArbitrageMatchVM implements IArbitrageMatchVM {
    id?: string;
    matchName?: string | undefined;
    league?: LeagueVM | undefined;
    homeTeam?: TeamVM | undefined;
    awayTeam?: TeamVM | undefined;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IArbitrageMatchVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.matchName = _data["matchName"];
            this.league = _data["league"] ? LeagueVM.fromJS(_data["league"]) : <any>undefined;
            this.homeTeam = _data["homeTeam"] ? TeamVM.fromJS(_data["homeTeam"]) : <any>undefined;
            this.awayTeam = _data["awayTeam"] ? TeamVM.fromJS(_data["awayTeam"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ArbitrageMatchVM {
        data = typeof data === 'object' ? data : {};
        let result = new ArbitrageMatchVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["matchName"] = this.matchName;
        data["league"] = this.league ? this.league.toJSON() : <any>undefined;
        data["homeTeam"] = this.homeTeam ? this.homeTeam.toJSON() : <any>undefined;
        data["awayTeam"] = this.awayTeam ? this.awayTeam.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IArbitrageMatchVM {
    id?: string;
    matchName?: string | undefined;
    league?: LeagueVM | undefined;
    homeTeam?: TeamVM | undefined;
    awayTeam?: TeamVM | undefined;
    startDate?: Date;
    endDate?: Date;
}

export class LeagueVM implements ILeagueVM {
    id?: number;
    name?: string | undefined;
    state?: StateVM | undefined;
    sport?: SportVM | undefined;

    constructor(data?: ILeagueVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"] ? StateVM.fromJS(_data["state"]) : <any>undefined;
            this.sport = _data["sport"] ? SportVM.fromJS(_data["sport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeagueVM {
        data = typeof data === 'object' ? data : {};
        let result = new LeagueVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["sport"] = this.sport ? this.sport.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILeagueVM {
    id?: number;
    name?: string | undefined;
    state?: StateVM | undefined;
    sport?: SportVM | undefined;
}

export class TeamVM implements ITeamVM {
    id?: number;
    name?: string | undefined;
    state?: StateVM | undefined;
    sport?: SportVM | undefined;
    league?: LeagueVM | undefined;

    constructor(data?: ITeamVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"] ? StateVM.fromJS(_data["state"]) : <any>undefined;
            this.sport = _data["sport"] ? SportVM.fromJS(_data["sport"]) : <any>undefined;
            this.league = _data["league"] ? LeagueVM.fromJS(_data["league"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamVM {
        data = typeof data === 'object' ? data : {};
        let result = new TeamVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["sport"] = this.sport ? this.sport.toJSON() : <any>undefined;
        data["league"] = this.league ? this.league.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITeamVM {
    id?: number;
    name?: string | undefined;
    state?: StateVM | undefined;
    sport?: SportVM | undefined;
    league?: LeagueVM | undefined;
}

export class CreateArbitrageBetCommand implements ICreateArbitrageBetCommand {
    arbitrageMatchId?: string;
    companyId?: number;
    accountId?: number;
    line?: string | undefined;
    statusId?: number | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    typeId?: number | undefined;

    constructor(data?: ICreateArbitrageBetCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.arbitrageMatchId = _data["arbitrageMatchId"];
            this.companyId = _data["companyId"];
            this.accountId = _data["accountId"];
            this.line = _data["line"];
            this.statusId = _data["statusId"];
            this.stake = _data["stake"];
            this.odd = _data["odd"];
            this.return = _data["return"];
            this.profit = _data["profit"];
            this.profitARB = _data["profitARB"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): CreateArbitrageBetCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArbitrageBetCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arbitrageMatchId"] = this.arbitrageMatchId;
        data["companyId"] = this.companyId;
        data["accountId"] = this.accountId;
        data["line"] = this.line;
        data["statusId"] = this.statusId;
        data["stake"] = this.stake;
        data["odd"] = this.odd;
        data["return"] = this.return;
        data["profit"] = this.profit;
        data["profitARB"] = this.profitARB;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface ICreateArbitrageBetCommand {
    arbitrageMatchId?: string;
    companyId?: number;
    accountId?: number;
    line?: string | undefined;
    statusId?: number | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    typeId?: number | undefined;
}

export class UpdateArbitrageBetCommand implements IUpdateArbitrageBetCommand {
    id?: number;
    arbitrageMatchId?: string;
    companyId?: number;
    accountId?: number;
    line?: string | undefined;
    statusId?: number | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    typeId?: number | undefined;

    constructor(data?: IUpdateArbitrageBetCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.arbitrageMatchId = _data["arbitrageMatchId"];
            this.companyId = _data["companyId"];
            this.accountId = _data["accountId"];
            this.line = _data["line"];
            this.statusId = _data["statusId"];
            this.stake = _data["stake"];
            this.odd = _data["odd"];
            this.return = _data["return"];
            this.profit = _data["profit"];
            this.profitARB = _data["profitARB"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): UpdateArbitrageBetCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArbitrageBetCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["arbitrageMatchId"] = this.arbitrageMatchId;
        data["companyId"] = this.companyId;
        data["accountId"] = this.accountId;
        data["line"] = this.line;
        data["statusId"] = this.statusId;
        data["stake"] = this.stake;
        data["odd"] = this.odd;
        data["return"] = this.return;
        data["profit"] = this.profit;
        data["profitARB"] = this.profitARB;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IUpdateArbitrageBetCommand {
    id?: number;
    arbitrageMatchId?: string;
    companyId?: number;
    accountId?: number;
    line?: string | undefined;
    statusId?: number | undefined;
    stake?: number;
    odd?: number;
    return?: number;
    profit?: number;
    profitARB?: number;
    typeId?: number | undefined;
}

export class UpdateArbitrageBetStatusCommand implements IUpdateArbitrageBetStatusCommand {
    id?: number;
    status?: string | undefined;

    constructor(data?: IUpdateArbitrageBetStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateArbitrageBetStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArbitrageBetStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateArbitrageBetStatusCommand {
    id?: number;
    status?: string | undefined;
}

export class CreateArbitrageMatchCommand implements ICreateArbitrageMatchCommand {
    leagueId?: number;
    homeTeamId?: number;
    awayTeamId?: number;
    matchName?: string | undefined;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: ICreateArbitrageMatchCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leagueId = _data["leagueId"];
            this.homeTeamId = _data["homeTeamId"];
            this.awayTeamId = _data["awayTeamId"];
            this.matchName = _data["matchName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateArbitrageMatchCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArbitrageMatchCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leagueId"] = this.leagueId;
        data["homeTeamId"] = this.homeTeamId;
        data["awayTeamId"] = this.awayTeamId;
        data["matchName"] = this.matchName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateArbitrageMatchCommand {
    leagueId?: number;
    homeTeamId?: number;
    awayTeamId?: number;
    matchName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
}

export class UpdateArbitrageMatchCommand implements IUpdateArbitrageMatchCommand {
    id?: string;
    leagueId?: number;
    homeTeamId?: number;
    awayTeamId?: number;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IUpdateArbitrageMatchCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.leagueId = _data["leagueId"];
            this.homeTeamId = _data["homeTeamId"];
            this.awayTeamId = _data["awayTeamId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateArbitrageMatchCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArbitrageMatchCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["leagueId"] = this.leagueId;
        data["homeTeamId"] = this.homeTeamId;
        data["awayTeamId"] = this.awayTeamId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateArbitrageMatchCommand {
    id?: string;
    leagueId?: number;
    homeTeamId?: number;
    awayTeamId?: number;
    startDate?: Date;
    endDate?: Date;
}

export class ClientVM implements IClientVM {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;

    constructor(data?: IClientVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): ClientVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IClientVM {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;
}

export class CreateClientCommand implements ICreateClientCommand {
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;

    constructor(data?: ICreateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CreateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface ICreateClientCommand {
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;
}

export class UpdateClientCommand implements IUpdateClientCommand {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;

    constructor(data?: IUpdateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): UpdateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IUpdateClientCommand {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    balance?: number;
}

export class CreateCompanyCommand implements ICreateCompanyCommand {
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    typeId?: number;

    constructor(data?: ICreateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.loginLink = _data["loginLink"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): CreateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["loginLink"] = this.loginLink;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface ICreateCompanyCommand {
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    typeId?: number;
}

export class UpdateCompanyCommand implements IUpdateCompanyCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    typeId?: number;

    constructor(data?: IUpdateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.loginLink = _data["loginLink"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): UpdateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["loginLink"] = this.loginLink;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IUpdateCompanyCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    loginLink?: string | undefined;
    typeId?: number;
}

export class CreateCurrencyCommand implements ICreateCurrencyCommand {
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICreateCurrencyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateCurrencyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCurrencyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICreateCurrencyCommand {
    name?: string | undefined;
    code?: string | undefined;
}

export class UpdateCurrencyCommand implements IUpdateCurrencyCommand {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IUpdateCurrencyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UpdateCurrencyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrencyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface IUpdateCurrencyCommand {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class CreateDepartmentCommand implements ICreateDepartmentCommand {
    name?: string | undefined;
    balance?: number;
    operators?: number[] | undefined;

    constructor(data?: ICreateDepartmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.balance = _data["balance"];
            if (Array.isArray(_data["operators"])) {
                this.operators = [] as any;
                for (let item of _data["operators"])
                    this.operators!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateDepartmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDepartmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["balance"] = this.balance;
        if (Array.isArray(this.operators)) {
            data["operators"] = [];
            for (let item of this.operators)
                data["operators"].push(item);
        }
        return data; 
    }
}

export interface ICreateDepartmentCommand {
    name?: string | undefined;
    balance?: number;
    operators?: number[] | undefined;
}

export class UpdateDepartmentCommand implements IUpdateDepartmentCommand {
    id?: number;
    name?: string | undefined;
    balance?: number;

    constructor(data?: IUpdateDepartmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): UpdateDepartmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDepartmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IUpdateDepartmentCommand {
    id?: number;
    name?: string | undefined;
    balance?: number;
}

export class CreateLeagueCommand implements ICreateLeagueCommand {
    name?: string | undefined;
    stateId?: number;
    sportId?: number;

    constructor(data?: ICreateLeagueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.stateId = _data["stateId"];
            this.sportId = _data["sportId"];
        }
    }

    static fromJS(data: any): CreateLeagueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeagueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["stateId"] = this.stateId;
        data["sportId"] = this.sportId;
        return data; 
    }
}

export interface ICreateLeagueCommand {
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
}

export class UpdateLeagueCommand implements IUpdateLeagueCommand {
    id?: number;
    name?: string | undefined;
    stateId?: number;
    sportId?: number;

    constructor(data?: IUpdateLeagueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.stateId = _data["stateId"];
            this.sportId = _data["sportId"];
        }
    }

    static fromJS(data: any): UpdateLeagueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeagueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["stateId"] = this.stateId;
        data["sportId"] = this.sportId;
        return data; 
    }
}

export interface IUpdateLeagueCommand {
    id?: number;
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
}

export class CreateOperatorCommand implements ICreateOperatorCommand {
    name?: string | undefined;
    balance?: number;
    departmentId?: number;
    clients?: number[] | undefined;

    constructor(data?: ICreateOperatorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.departmentId = _data["departmentId"];
            if (Array.isArray(_data["clients"])) {
                this.clients = [] as any;
                for (let item of _data["clients"])
                    this.clients!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOperatorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOperatorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["departmentId"] = this.departmentId;
        if (Array.isArray(this.clients)) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item);
        }
        return data; 
    }
}

export interface ICreateOperatorCommand {
    name?: string | undefined;
    balance?: number;
    departmentId?: number;
    clients?: number[] | undefined;
}

export class UpdateOperatorCommand implements IUpdateOperatorCommand {
    id?: number;
    name?: string | undefined;
    balance?: number;
    departmentId?: number;

    constructor(data?: IUpdateOperatorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): UpdateOperatorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOperatorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["departmentId"] = this.departmentId;
        return data; 
    }
}

export interface IUpdateOperatorCommand {
    id?: number;
    name?: string | undefined;
    balance?: number;
    departmentId?: number;
}

export class CreatePaymentAccountCommand implements ICreatePaymentAccountCommand {
    id?: number;
    companyId?: number;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    stateId?: number;
    statusId?: number;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;

    constructor(data?: ICreatePaymentAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.stateId = _data["stateId"];
            this.statusId = _data["statusId"];
            this.balance = _data["balance"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.documentExpiry = _data["documentExpiry"] ? new Date(_data["documentExpiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreatePaymentAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["stateId"] = this.stateId;
        data["statusId"] = this.statusId;
        data["balance"] = this.balance;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["documentExpiry"] = this.documentExpiry ? this.documentExpiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreatePaymentAccountCommand {
    id?: number;
    companyId?: number;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    stateId?: number;
    statusId?: number;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;
}

export class UpdatePaymentAccountCommand implements IUpdatePaymentAccountCommand {
    id?: number;
    companyId?: number;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    stateId?: number;
    statusId?: number;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;

    constructor(data?: IUpdatePaymentAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.stateId = _data["stateId"];
            this.statusId = _data["statusId"];
            this.balance = _data["balance"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.documentExpiry = _data["documentExpiry"] ? new Date(_data["documentExpiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePaymentAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["stateId"] = this.stateId;
        data["statusId"] = this.statusId;
        data["balance"] = this.balance;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["documentExpiry"] = this.documentExpiry ? this.documentExpiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdatePaymentAccountCommand {
    id?: number;
    companyId?: number;
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    stateId?: number;
    statusId?: number;
    balance?: number;
    name?: string | undefined;
    surname?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    documentExpiry?: Date;
}

export class CreateSportCommand implements ICreateSportCommand {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateSportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateSportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateSportCommand {
    name?: string | undefined;
    description?: string | undefined;
}

export class UpdateSportCommand implements IUpdateSportCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateSportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateSportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateSportCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateStateCommand implements ICreateStateCommand {
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICreateStateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateStateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICreateStateCommand {
    name?: string | undefined;
    code?: string | undefined;
}

export class UpdateStateCommand implements IUpdateStateCommand {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IUpdateStateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UpdateStateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface IUpdateStateCommand {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class CreateStatusCommand implements ICreateStatusCommand {
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: ICreateStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): CreateStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface ICreateStatusCommand {
    name?: string | undefined;
    environment?: string | undefined;
}

export class UpdateStatusCommand implements IUpdateStatusCommand {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: IUpdateStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): UpdateStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface IUpdateStatusCommand {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;
}

export class CreateTeamCommand implements ICreateTeamCommand {
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
    leagueId?: number;

    constructor(data?: ICreateTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.stateId = _data["stateId"];
            this.sportId = _data["sportId"];
            this.leagueId = _data["leagueId"];
        }
    }

    static fromJS(data: any): CreateTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["stateId"] = this.stateId;
        data["sportId"] = this.sportId;
        data["leagueId"] = this.leagueId;
        return data; 
    }
}

export interface ICreateTeamCommand {
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
    leagueId?: number;
}

export class UpdateTeamCommand implements IUpdateTeamCommand {
    id?: number;
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
    leagueId?: number;

    constructor(data?: IUpdateTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.stateId = _data["stateId"];
            this.sportId = _data["sportId"];
            this.leagueId = _data["leagueId"];
        }
    }

    static fromJS(data: any): UpdateTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["stateId"] = this.stateId;
        data["sportId"] = this.sportId;
        data["leagueId"] = this.leagueId;
        return data; 
    }
}

export interface IUpdateTeamCommand {
    id?: number;
    name?: string | undefined;
    stateId?: number;
    sportId?: number;
    leagueId?: number;
}

export class CreateTypeCommand implements ICreateTypeCommand {
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: ICreateTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): CreateTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface ICreateTypeCommand {
    name?: string | undefined;
    environment?: string | undefined;
}

export class UpdateTypeCommand implements IUpdateTypeCommand {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;

    constructor(data?: IUpdateTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): UpdateTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["environment"] = this.environment;
        return data; 
    }
}

export interface IUpdateTypeCommand {
    id?: number;
    name?: string | undefined;
    environment?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}